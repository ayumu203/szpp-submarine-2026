classDiagram
direction LR

namespace presentation {
  class GameHandler {
    +HandleInitialize(req)
    +HandleAction(req)
    +HandleState(gameId: GameId, viewerPlayerId: PlayerId)
  }
}

namespace application {
  class GameService {
    +InitializeGame(playerAId: PlayerId, playerBId: PlayerId, playerAPosition) Game
    +ExecuteTurn(gameId: GameId, command) TurnResult
    +ExecuteCpuTurn(gameId: GameId, playerId: PlayerId) TurnResult
    +GetGameState(gameId: GameId, viewerPlayerId: PlayerId) GameState
  }

  class CpuDecisionService {
    +DecideAction(game) ActionCommand
  }

  class CpuAnalysisService {
    +RecordTurn(gameId: GameId, turnLog)
    +UpdatePrediction(gameId: GameId) PredictionBoard
    +GetPrediction(gameId: GameId) PredictionBoard
  }

  class GameState {
    +gameId GameId
    +turn int
    +status GameStatus
    +currentPlayerId PlayerId
    +opponentId PlayerId
    +board Board
    +predictionBoard PredictionBoard
    +logs TurnLog[]
  }
}

namespace domain {
  class Game {
    -id GameId
    -status GameStatus
    -turn int
    -playerAId PlayerId
    -playerBId PlayerId
    -currentPlayerId PlayerId
    -winnerId PlayerId
    -createdAt string
    -updatedAt string
    +Start()
    +Apply(command) TurnResult
    +IsFinished() bool
  }

  class Board {
    -submarines map~SubmarineId,Submarine~
    +PlaceSubmarine(playerId: PlayerId, position) error
    +MoveSubmarine(playerId: PlayerId, submarineId: SubmarineId, direction, distance) bool
    +FindTargets(attackerId: PlayerId, center) Submarine[]
    +IsOccupied(position) bool
    +GetAllySubmarineAt(playerId: PlayerId, position) Submarine
    +GetOpponentSubmarineAt(playerId: PlayerId, position) Submarine
    +GetAllySubmarines(playerId: PlayerId) Submarine[]
    +GetOpponentSubmarines(playerId: PlayerId) Submarine[]
  }

  class Player {
    -id PlayerId
    -name string
    +RemainingHp() int
  }

  class Submarine {
    -id SubmarineId
    -ownerId PlayerId
    -position Position
    -hp int
    +IsSunk() bool
    +TakeDamage(amount) error
    +MoveTo(position) error
  }

  class Position {
    -x int
    -y int
    +WithinBoard() bool
    +Neighbors8() Position[]
    +GetPosition() Position
  }

  class ActionCommand {
    -playerId PlayerId
    -type ActionType
    -target Position
    -direction Direction
    -distance int
  }

  class TurnResult {
    -attackReport AttackReportType
    -moveReport MoveReportType
    -errorCode ErrorCode
    -sunkCount int
    -nextPlayerId PlayerId
  }

  class TurnLog {
    -gameId GameId
    -turn int
    -playerId PlayerId
    -actionType ActionType
    -target Position
    -direction Direction
    -distance int
    -attackReport AttackReportType
    -moveReport MoveReportType
    -errorCode ErrorCode
    -createdAt string
  }

  class PredictionBoard {
    -scoreGrid int[5][5]
    -enemyPossibility float32[5][5]
    -updatedAt string
    +MarkHit(position)
    +MarkMiss(position)
    +MarkHighWave(position, weight)
    +MarkSunk(position, weight)
    +BestAttackCell() Position
    +BestMoveCell(submarineId: SubmarineId) Position
  }

  class GameId {
    -value string
    +String() string
  }

  class PlayerId {
    -value string
    +String() string
  }

  class SubmarineId {
    -value string
    +String() string
  }

  class GameRepository {
    <<interface>>
    +Save(game) error
    +FindById(gameId: GameId) Game
  }

  class TurnLogRepository {
    <<interface>>
    +Append(gameId: GameId, log) error
    +FindByGameId(gameId: GameId) TurnLog[]
  }

  class PredictionRepository {
    <<interface>>
    +Save(gameId: GameId, board) error
    +Find(gameId: GameId) PredictionBoard
  }

  class PlayerGamesIndexRepository {
    <<interface>>
    +AddGame(playerId: PlayerId, gameId: GameId) error
    +RemoveGame(playerId: PlayerId, gameId: GameId) error
    +ListGames(playerId: PlayerId) GameId[]
  }

  class CpuPlayer {
    <<interface>>
    +Decide(game) ActionCommand
  }

  class GameStatus {
    <<enumeration>>
    waiting
    inProgress
    finished
  }

  class ActionType {
    <<enumeration>>
    attack
    move
  }

  class Direction {
    <<enumeration>>
    north
    south
    east
    west
  }

  class AttackReportType {
    <<enumeration>>
    invalidAttack
    miss
    hit
    hitAndSunk
    waveHigh
  }

  class MoveReportType {
    <<enumeration>>
    moveSuccess
    moveBlocked
  }

  class ErrorCode {
    <<enumeration>>
    invalidTurn
    invalidAction
    invalidTarget
    invalidMoveDistance
    outOfBoard
  }
}

namespace infrastructure {
  class UpstashGameRepository {
    +Save(game) error
    +FindById(gameId: GameId) Game
  }

  class RandomCpuPlayer {
    +Decide(game) ActionCommand
  }

  class UpstashTurnLogRepository {
    +Append(gameId: GameId, log) error
    +FindByGameId(gameId: GameId) TurnLog[]
  }

  class UpstashPredictionRepository {
    +Save(gameId: GameId, playerId: PlayerId, board) error
    +Find(gameId: GameId, playerId: PlayerId) PredictionBoard
  }

  class UpstashPlayerGamesIndexRepository {
    +AddGame(playerId: PlayerId, gameId: GameId) error
    +RemoveGame(playerId: PlayerId, gameId: GameId) error
    +ListGames(playerId: PlayerId) GameId[]
  }
}

GameHandler --> GameService : uses
GameService --> GameRepository : depends on
GameService --> PlayerGamesIndexRepository : depends on
GameService --> CpuDecisionService : uses
GameService --> CpuAnalysisService : uses
GameService --> TurnLogRepository : depends on
GameService --> PredictionRepository : depends on
CpuDecisionService --> CpuPlayer : depends on
CpuDecisionService --> CpuAnalysisService : uses
CpuAnalysisService --> TurnLogRepository : depends on
CpuAnalysisService --> PredictionRepository : depends on
CpuAnalysisService --> PredictionBoard : builds/updates

Game --> Board : has
Game --> Player : has 2
Player --> Submarine : owns 0..4
Submarine --> Position : has
Game --> GameId : uses
Player --> PlayerId : uses
Submarine --> SubmarineId : uses
Game --> ActionCommand : applies
Game --> TurnResult : returns
Game --> TurnLog : emits
GameService --> GameState : returns

GameRepository <|.. UpstashGameRepository : implements
CpuPlayer <|.. RandomCpuPlayer : implements
TurnLogRepository <|.. UpstashTurnLogRepository : implements
PredictionRepository <|.. UpstashPredictionRepository : implements
PlayerGamesIndexRepository <|.. UpstashPlayerGamesIndexRepository : implements
PredictionRepository --> PredictionBoard : stores/loads
