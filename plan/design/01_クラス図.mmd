classDiagram
direction LR

namespace presentation {
  class GameHandler {
    +HandleInitialize(req)
    +HandleAction(req)
    +HandleState(gameId, viewerPlayerId)
  }
}

namespace application {
  class GameService {
    +InitializeGame(playerAId, playerBId, playerAPosition) Game
    +ExecuteTurn(gameId, command) TurnResult
    +ExecuteCpuTurn(gameId, playerId) TurnResult
    +GetGameState(gameId, viewerPlayerId) GameState
  }

  class CpuDecisionService {
    +DecideAction(game) ActionCommand
  }

  class CpuAnalysisService {
    +RecordTurn(gameId, turnLog)
    +UpdatePrediction(gameId) PredictionBoard
    +GetPrediction(gameId) PredictionBoard
  }

  class GameState {
    +gameId string
    +turn int
    +status GameStatus
    +currentPlayerId string
    +opponentId string
    +board Board
    +predictionBoard PredictionBoard
    +logs TurnLog[]
  }
}

namespace domain {
  class Game {
    -id string
    -status GameStatus
    -turn int
    -playerAId string
    -playerBId string
    -currentPlayerId string
    -winnerId string
    -createdAt string
    -updatedAt string
    +Start()
    +Apply(command) TurnResult
    +IsFinished() bool
  }

  class Board {
    -submarines map~string,Submarine~
    +PlaceSubmarine(playerId, position) error
    +MoveSubmarine(playerId, submarineId, direction, distance) bool
    +FindTargets(attackerId, center) Submarine[]
    +IsOccupied(position) bool
    +GetAllySubmarineAt(playerId, position) Submarine
    +GetOpponentSubmarineAt(playerId,position) Submarine
    +GetAllySubmarines(playerId) Submarine[]
    +GetOpponentSubmarines(playerId) Submarine[]
  }

  class Player {
    -id string
    -name string
    +RemainingHp() int
  }

  class Submarine {
    -id string
    -ownerId string
    -position Position
    -hp int
    +IsSunk() bool
    +TakeDamage(amount) error
    +MoveTo(position) error
  }

  class Position {
    -x int
    -y int
    +Neighbors8() Position[]
    +GetPosition() int, int
    -withinBoard() bool
    -isEqual() bool
  }

  class ActionCommand {
    -playerId string
    -type ActionType
    -target Position
    -direction Direction
    -distance int
  }

  class TurnResult {
    -attackReport AttackReportType
    -moveReport MoveReportType
    -errorCode ErrorCode
    -sunkCount int
    -nextPlayerId string
  }

  class TurnLog {
    -gameId string
    -turn int
    -playerId string
    -actionType ActionType
    -target Position
    -direction Direction
    -distance int
    -attackReport AttackReportType
    -moveReport MoveReportType
    -errorCode ErrorCode
    -createdAt string
  }

  class PredictionBoard {
    -scoreGrid int[5][5]
    -enemyPossibility float32[5][5]
    -updatedAt string
    +MarkHit(position)
    +MarkMiss(position)
    +MarkHighWave(position, weight)
    +MarkSunk(position, weight)
    +BestAttackCell() Position
    +BestMoveCell(submarineId: string) Position
  }

  class GameRepository {
    <<interface>>
    +Save(game) error
    +FindById(gameId) Game
  }

  class TurnLogRepository {
    <<interface>>
    +Append(gameId,log) error
    +FindByGameId(gameId) TurnLog[]
  }

  class PredictionRepository {
    <<interface>>
    +Save(gameId, board) error
    +Find(gameId) PredictionBoard
  }

  class PlayerGamesIndexRepository {
    <<interface>>
    +AddGame(playerId, gameId) error
    +RemoveGame(playerId, gameId) error
    +ListGames(playerId) string[]
  }

  class CpuPlayer {
    <<interface>>
    +Decide(game) ActionCommand
  }

  class GameStatus {
    <<enumeration>>
    waiting
    inProgress
    finished
  }

  class ActionType {
    <<enumeration>>
    attack
    move
  }

  class Direction {
    <<enumeration>>
    north
    south
    east
    west
  }

  class AttackReportType {
    <<enumeration>>
    invalidAttack
    miss
    hit
    hitAndSunk
    waveHigh
  }

  class MoveReportType {
    <<enumeration>>
    moveSuccess
    moveBlocked
  }

  class ErrorCode {
    <<enumeration>>
    invalidTurn
    invalidAction
    invalidTarget
    invalidMoveDistance
    outOfBoard
  }
}

namespace infrastructure {
  class UpstashGameRepository {
    +Save(game) error
    +FindById(gameId) Game
  }

  class RandomCpuPlayer {
    +Decide(game) ActionCommand
  }

  class UpstashTurnLogRepository {
    +Append(gameId, log) error
    +FindByGameId(gameId) TurnLog[]
  }

  class UpstashPredictionRepository {
    +Save(gameId, playerId, board) error
    +Find(gameId, playerId) PredictionBoard
  }

  class UpstashPlayerGamesIndexRepository {
    +AddGame(playerId, gameId) error
    +RemoveGame(playerId, gameId) error
    +ListGames(playerId) string[]
  }
}

GameHandler --> GameService : uses
GameService --> GameRepository : depends on
GameService --> PlayerGamesIndexRepository : depends on
GameService --> CpuDecisionService : uses
GameService --> CpuAnalysisService : uses
GameService --> TurnLogRepository : depends on
GameService --> PredictionRepository : depends on
CpuDecisionService --> CpuPlayer : depends on
CpuDecisionService --> CpuAnalysisService : uses
CpuAnalysisService --> TurnLogRepository : depends on
CpuAnalysisService --> PredictionRepository : depends on
CpuAnalysisService --> PredictionBoard : builds/updates

Game --> Board : has
Game --> Player : has 2
Player --> Submarine : owns 0..4
Submarine --> Position : has
Game --> ActionCommand : applies
Game --> TurnResult : returns
Game --> TurnLog : emits
GameService --> GameState : returns

GameRepository <|.. UpstashGameRepository : implements
CpuPlayer <|.. RandomCpuPlayer : implements
TurnLogRepository <|.. UpstashTurnLogRepository : implements
PredictionRepository <|.. UpstashPredictionRepository : implements
PlayerGamesIndexRepository <|.. UpstashPlayerGamesIndexRepository : implements
PredictionRepository --> PredictionBoard : stores/loads
